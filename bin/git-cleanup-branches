#!/usr/bin/env bash
# git-cleanup-branches - Find and optionally delete local branches that can be safely removed
# 
# This script identifies:
# 1. LOCAL: Branches where the remote tracking branch is gone (deleted)
# 2. LOCAL: Branches with no unique commits compared to origin/main
#
# Usage:
#   git-cleanup-branches          # List candidates (dry run)
#   git-cleanup-branches --delete # Interactively delete each branch
#   git-cleanup-branches --force  # Delete all branches without prompting

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

MODE="${1:-list}"
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)
MAIN_BRANCH="origin/main"

# Update remote tracking information
echo -e "${BLUE}Fetching and pruning remote tracking branches...${NC}"
git fetch --prune --quiet

echo ""
echo -e "${GREEN}=== Local Branches Safe to Delete ===${NC}"
echo ""

# Arrays to store branches by category
declare -a GONE_BRANCHES=()
declare -a NO_DIFF_BRANCHES=()

# Find branches where remote is gone (sorted by commit date, oldest first)
while IFS= read -r line; do
    # Extract just the branch name from the format output
    branch=$(echo "$line" | awk '{print $NF}')
    # Skip current branch and protected branches
    if [[ "$branch" == "$CURRENT_BRANCH" ]] || [[ "$branch" =~ ^(main|master|develop|development)$ ]]; then
        continue
    fi
    GONE_BRANCHES+=("$line")
done < <(git for-each-ref --sort=committerdate --format='%(committerdate:short) %(refname:short)' refs/heads/ | while read date branch; do
    if git branch -vv | grep "^..${branch}" | grep -q ': gone]'; then
        echo "$date $branch"
    fi
done || true)

# Find branches with no unique commits vs origin/main (sorted by commit date, oldest first)
while IFS= read -r line; do
    date=$(echo "$line" | awk '{print $1}')
    branch=$(echo "$line" | awk '{print $2}')
    
    # Skip current branch, protected branches, and already found branches
    if [[ "$branch" == "$CURRENT_BRANCH" ]] || [[ "$branch" =~ ^(main|master|develop|development)$ ]]; then
        continue
    fi
    
    # Skip if already in GONE_BRANCHES
    skip=false
    for gone in "${GONE_BRANCHES[@]:-}"; do
        gone_branch=$(echo "$gone" | awk '{print $NF}')
        if [[ "$branch" == "$gone_branch" ]]; then
            skip=true
            break
        fi
    done
    [[ "$skip" == true ]] && continue
    
    # Check if branch has any unique commits
    if ! git rev-parse "$branch" &>/dev/null; then
        continue
    fi
    
    unique_commits=$(git log --oneline "$MAIN_BRANCH..$branch" 2>/dev/null | wc -l)
    if [[ "$unique_commits" -eq 0 ]]; then
        NO_DIFF_BRANCHES+=("$date $branch")
    fi
done < <(git for-each-ref --sort=committerdate --format='%(committerdate:short) %(refname:short)' refs/heads/ || true)

# Display results
if [[ ${#GONE_BRANCHES[@]} -gt 0 ]]; then
    echo -e "${YELLOW}Remote tracking branch deleted (${#GONE_BRANCHES[@]}) - sorted by commit date:${NC}"
    for line in "${GONE_BRANCHES[@]}"; do
        date=$(echo "$line" | awk '{print $1}')
        branch=$(echo "$line" | awk '{print $2}')
        echo "  $date - $branch"
    done
    echo ""
fi

if [[ ${#NO_DIFF_BRANCHES[@]} -gt 0 ]]; then
    echo -e "${YELLOW}No unique commits vs origin/main (${#NO_DIFF_BRANCHES[@]}) - sorted by commit date:${NC}"
    for line in "${NO_DIFF_BRANCHES[@]}"; do
        date=$(echo "$line" | awk '{print $1}')
        branch=$(echo "$line" | awk '{print $2}')
        echo "  $date - $branch"
    done
    echo ""
fi

# Combine all branches to delete (extract just branch names)
ALL_BRANCHES=()
if [[ ${#GONE_BRANCHES[@]} -gt 0 ]]; then
    for line in "${GONE_BRANCHES[@]}"; do
        branch=$(echo "$line" | awk '{print $NF}')
        ALL_BRANCHES+=("$branch")
    done
fi
if [[ ${#NO_DIFF_BRANCHES[@]} -gt 0 ]]; then
    for line in "${NO_DIFF_BRANCHES[@]}"; do
        branch=$(echo "$line" | awk '{print $NF}')
        ALL_BRANCHES+=("$branch")
    done
fi

if [[ ${#ALL_BRANCHES[@]} -eq 0 ]]; then
    echo -e "${GREEN}No local branches found that can be safely deleted.${NC}"
    exit 0
fi

echo -e "${BLUE}Total branches to clean up: ${#ALL_BRANCHES[@]}${NC}"
echo ""

# Handle deletion based on mode
case "$MODE" in
    --delete)
        echo -e "${YELLOW}Interactive deletion mode${NC}"
        for branch in "${ALL_BRANCHES[@]}"; do
            read -p "Delete branch '$branch'? (y/n) " -n 1 -r
            echo
            if [[ $REPLY =~ ^[Yy]$ ]]; then
                git branch -D "$branch"
                echo -e "${GREEN}✓ Deleted $branch${NC}"
            else
                echo -e "${BLUE}  Skipped $branch${NC}"
            fi
        done
        ;;
    --force)
        echo -e "${RED}Force deletion mode - deleting all branches without prompting${NC}"
        for branch in "${ALL_BRANCHES[@]}"; do
            git branch -D "$branch"
            echo -e "${GREEN}✓ Deleted $branch${NC}"
        done
        ;;
    *)
        echo -e "${YELLOW}Dry run mode (no branches deleted)${NC}"
        echo "To delete branches, run with:"
        echo "  git-cleanup-branches --delete  (interactive)"
        echo "  git-cleanup-branches --force   (delete all)"
        echo ""
        echo "Or delete individual branches with:"
        for branch in "${ALL_BRANCHES[@]}"; do
            echo "  git branch -D $branch"
        done
        ;;
esac
